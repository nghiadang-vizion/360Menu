<!DOCTYPE html>
<html>
  <head>
    <meta charset=UTF-8 />
    <link rel="stylesheet" type="text/css" href="styles.css" />
  </head>
  <body>

    <div class="tooltip"></div>

    <script src="./js/TweenLite.min.js"></script>
    <script type="module">
      import * as THREE from './build/three.module.js';
      import { OrbitControls } from './js/OrbitControls.js';
      import { FlakesTexture } from './js/FlakesTexture.js';
      import { RGBELoader } from './js/RGBELoader.js';

      let scene, camera, renderer, controls, pointlight;
      const container = document.body;
      const tooltip = document.querySelector('.tooltip')
      let spriteActive = false;

      class Scene {
        constructor (image, camera){
          this.image = image;
          this.points = [];
          this.sprites = [];
          this.scene = null;
          this.camera = camera;
        }

        createScene (scene){
          this.scene = scene;
          let ballGeo = new THREE.SphereGeometry(100,32,32);
          // let plane = new THREE.PlaneGeometry( 1, 1 );
          const texture =  new THREE.TextureLoader().load(this.image);
          texture.wrapS = THREE.RepeatWrapping;
          texture.repeat.x = -1;
          let material = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.DoubleSide,
          });
          // material.transparent = true;
          this.sphere = new THREE.Mesh(ballGeo,material);
          // this.plane = new THREE.Mesh(plane,material);
          this.scene.add(this.sphere);
          // this.scene.add(this.plane);
          this.points.forEach(this.addTooltip.bind(this));
        }

        createPlane(scene){
          this.scene = scene;
          let plane = new THREE.PlaneGeometry( 1, 1 );
          const texture =  new THREE.TextureLoader().load('img/hinh1.jpg');
          texture.wrapS = THREE.RepeatWrapping;
          texture.repeat.x = 1;
          let material = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.DoubleSide,
          });
          this.plane = new THREE.Mesh(plane,material);
          
          this.scene.add(this.plane);
          this.points.forEach(this.addTooltip.bind(this));
        }

        addPoint (point){
          this.points.push(point);
        }

        addTooltip(point) {
          let spriteMap = new THREE.TextureLoader().load( 'img/menu.png' );
          let spriteMaterial = new THREE.SpriteMaterial( { map: spriteMap } );

          let sprite = new THREE.Sprite( spriteMaterial );
          sprite.name = point.name;
          sprite.position.copy(point.position.clone().normalize().multiplyScalar(30));
          sprite.scale.multiplyScalar(2)
          this.scene.add( sprite );
          this.sprites.push(sprite);
          sprite.onclick = () => {
            this.destroy()
            point.scene.createScene(scene);
            point.scene.appear();
          }
        }

        destroy(){
          TweenLite.to(this.sphere.material, 1, {
            opacity: 0,
            onComplete: () => {
              this.scene.remove(this.sphere);
            }
          })
          this.sprites.forEach((sprite) => {
            TweenLite.to(sprite.scale, 1, {
            x:0,
            y:0,
            z:0,
            onComplete: () => {
              this.scene.remove(sprite);
            }
          })
          })
        }

        appear(){
          this.sphere.material.opacity = 0;
          TweenLite.to(this.sphere.material, 1, {
            opacity: 1,
          })
          this.sprites.forEach((sprite) => {
            sprite.scale.set(0,0,0)
            TweenLite.to(sprite.scale, 1, {
            x:2,
            y:2,
            z:2
          })
          })
        }
      }

      function init() {
        scene = new THREE.Scene();

        renderer = new THREE.WebGLRenderer({alpha:true,antialias:true});
        renderer.setSize(window.innerWidth,window.innerHeight);
        container.appendChild(renderer.domElement);

        camera = new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,1,1000);
        camera.position.set(-1,0,1);
        controls = new OrbitControls(camera, renderer.domElement);

        // controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.enableDamping = true;
        controls.enableZoom = false;

        // pointlight = new THREE.PointLight(0xffffff,1);
        // pointlight.position.set(200,200,200);
        // scene.add(pointlight);

        let envmaploader = new THREE.PMREMGenerator(renderer);

        let s = new Scene('./textures/northcliff.jpg', camera)
        let s2 = new Scene('./textures/kloofendal_38d_partly_cloudy.jpg', camera)
        let menu = new Scene(camera)
        s.addPoint({
          position: new THREE.Vector3 (-4.420648133092449,33.945512552766665,-93.49929162862449),
          name: 'ulatr',
          scene: s2
        })
        s2.addPoint({
          position: new THREE.Vector3 (-4.420648133092449,33.945512552766665,-93.49929162862449),
          name: 'ulatr',
          scene: s
        })
        s.createScene(scene);
        s.createPlane(scene);
        s.appear();

        function onResize() {
          renderer.setSize(window.innerWidth,window.innerHeight)
          camera.aspect = window.innerWidth/window.innerHeight
          camera.updateProjectionMatrix()
        }

        const rayCaster = new THREE.Raycaster();

        function onclick(e) {
          let mouse = new THREE.Vector2(( e.clientX / window.innerWidth ) * 2 - 1,- ( e.clientY / window.innerHeight ) * 2 + 1);
          console.log(mouse);
          rayCaster.setFromCamera(mouse,camera);
          let intersects = rayCaster.intersectObjects( scene.children );
          intersects.forEach(function (intersect) {
            if (intersect.object.type === 'Sprite') {
              intersect.object.onclick();
            }
          })
          
        }
        function onMouseMove(e) {
          let mouse = new THREE.Vector2(( e.clientX / window.innerWidth ) * 2 - 1,- ( e.clientY / window.innerHeight ) * 2 + 1);
          rayCaster.setFromCamera(mouse,camera);
          let foundSprite = false;
          let intersects = rayCaster.intersectObjects( scene.children );
          intersects.forEach(function (intersect) {
            if (intersect.object.type === 'Sprite') {
              let p = intersect.object.position.clone().project(camera);
              tooltip.style.top = ((-1 * p.y + 1) * window.innerHeight /2) + 'px';
              tooltip.style.left = ((p.x +2 ) * window.innerHeight /2) + 'px';
              tooltip.classList.add('active');
              tooltip.innerHTML = intersect.object.name;
              spriteActive = intersect.object;
              foundSprite = true;
            }
          })
          if (foundSprite === false && spriteActive) {
            tooltip.classList.remove('active');
            spriteActive = false;    
          }
        }
        window.addEventListener('resize',onResize)
        container.addEventListener('click', onclick)
        container.addEventListener('mousemove', onMouseMove)
        animate();
      }
      function animate() {
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      init();
    </script>
  </body>
</html>
